name: CI/CD â€” ECR + Elastic Beanstalk

on:
  push:
    branches: [ main ]
    paths:
      - 'Dockerfile'
      - 'requirements.txt'
      - 'app.py'
      - 'src/**'
      - '.github/workflows/deploy.yml'
  workflow_dispatch:

concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # Building locally and performing smoke-test (Streamlit on 8080)
  smoke-test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Build local image
        run: |
          docker build -t fair-tutor:${{ github.sha }} .

      - name: Run container (8080)
        run: |
          docker run -d --name app -p 8080:8080 fair-tutor:${{ github.sha }}
          # Wait for Streamlit to come up
          for i in {1..20}; do
            sleep 3
            if curl -sf http://localhost:8080/ >/dev/null; then
              echo "App responded OK"
              exit 0
            fi
            echo "Waiting for app..."
          done
          echo "App failed to respond in time" >&2
          docker logs app || true
          exit 1

      - name: Show container logs (always)
        if: always()
        run: docker logs app || true

      - name: Stop container (always)
        if: always()
        run: docker stop app || true

  # Building & pushing image to ECR (linux/amd64)
  build-and-push-ecr:
    needs: smoke-test
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    env:
      AWS_REGION: ${{ secrets.AWS_REGION }}
      ECR_REPO: ${{ secrets.ECR_REPOSITORY }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build & Push (linux/amd64)
        uses: docker/build-push-action@v6
        with:
          context: .
          file: Dockerfile
          platforms: linux/amd64
          push: true
          tags: |
            ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPO }}:latest
            ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPO }}:${{ github.sha }}

  # Creating a unique EB application version and deploying
  deploy-eb:
    needs: build-and-push-ecr
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    env:
      AWS_REGION: ${{ secrets.AWS_REGION }}
      EB_APP: ${{ secrets.EB_APP_NAME }}
      EB_ENV: ${{ secrets.EB_ENV_NAME }}
      EB_BUCKET: ${{ secrets.EB_S3_BUCKET }}
      ECR_REPO: ${{ secrets.ECR_REPOSITORY }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Compute unique version label
        run: |
          SHORT_SHA=$(echo "${GITHUB_SHA}" | cut -c1-8)
          TS=$(date -u +%Y%m%d%H%M%S)
          echo "VERLABEL=v-${GITHUB_RUN_NUMBER}-${TS}-${SHORT_SHA}" >> $GITHUB_ENV
          echo "Computed VERLABEL=${VERLABEL}"

      - name: Create Dockerrun.aws.json (port 8080, :latest)
        run: |
          aws ecr get-login-password --region "${AWS_REGION}" >/dev/null
          # The registry is account.dkr.ecr.region.amazonaws.com
          REGISTRY="${{ github.repository_owner }}.dkr.ecr.${AWS_REGION}.amazonaws.com"
          # But safer to read from EB env bucket? We already logged into ECR in prior job; here we craft directly:
          # If you prefer exact registry from account id, set it as a secret. Otherwise infer from EB bucket/account if needed.
          # Since the image name in EB only needs "<registry>/<repo>:latest", we can leverage the same format you used manually:
          # If you want to hardcode, replace REGISTRY line with: REGISTRY="864624564382.dkr.ecr.${AWS_REGION}.amazonaws.com"

          # If you prefer to hardcode registry, uncomment the next line and set your account id:
          # REGISTRY="864624564382.dkr.ecr.${AWS_REGION}.amazonaws.com"

          # If you want to avoid inference, set a secret ECR_REGISTRY and use it:
          # REGISTRY="${{ secrets.ECR_REGISTRY }}"

          # For safety, default to secrets.ECR_REGISTRY if provided:
          if [ -n "${{ secrets.ECR_REGISTRY }}" ]; then REGISTRY="${{ secrets.ECR_REGISTRY }}"; fi

          cat > Dockerrun.aws.json <<JSON
          {
            "AWSEBDockerrunVersion": "1",
            "Image": {
              "Name": "${REGISTRY}/${{ env.ECR_REPO }}:latest",
              "Update": "true"
            },
            "Ports": [
              { "ContainerPort": "8080" }
            ],
            "Logging": "/var/log/nginx"
          }
          JSON
          cat Dockerrun.aws.json

      - name: Package bundle
        run: |
          zip -j "beanstalk-bundle-${VERLABEL}.zip" Dockerrun.aws.json

      - name: Upload bundle to S3
        run: |
          KEY="ci/fair-tutor/beanstalk-bundle-${VERLABEL}.zip"
          aws s3 cp "beanstalk-bundle-${VERLABEL}.zip" "s3://${EB_BUCKET}/${KEY}"
          echo "BUNDLE_KEY=${KEY}" >> $GITHUB_ENV
          echo "Uploaded to s3://${EB_BUCKET}/${KEY}"

      - name: Create EB application version (unique every run)
        run: |
          aws elasticbeanstalk create-application-version \
            --application-name "${EB_APP}" \
            --version-label "${VERLABEL}" \
            --source-bundle S3Bucket="${EB_BUCKET}",S3Key="${BUNDLE_KEY}"

      - name: Deploy to EB environment
        run: |
          aws elasticbeanstalk update-environment \
            --environment-name "${EB_ENV}" \
            --version-label "${VERLABEL}"